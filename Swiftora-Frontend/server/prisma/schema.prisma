generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  phone         String   @unique
  name          String
  passwordHash  String?
  role          UserRole @default(USER)
  isActive      Boolean  @default(true)
  
  merchantId    String?
  merchant      Merchant? @relation(fields: [merchantId], references: [id])
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  sessions      Session[]
  orders        Order[]
  pickups       Pickup[]
  passwordResets PasswordReset[]
  tickets       Ticket[]
  
  @@index([merchantId])
  @@index([email])
  @@index([phone])
}

enum UserRole {
  ADMIN
  MANAGER
  USER
  VIEWER
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([token])
}

model PasswordReset {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  used      Boolean  @default(false)
  
  @@index([userId])
  @@index([token])
}

model Merchant {
  id                String   @id @default(cuid())
  companyName       String
  gstNumber         String?
  email             String   @unique
  phone             String
  address           String?
  city              String?
  state             String?
  pincode           String?
  
  shippingType      ShippingType @default(B2C)
  monthlyVolume     String?
  b2bEnabled        Boolean  @default(false)
  
  walletBalance     Decimal  @default(0) @db.Decimal(12, 2)
  creditLimit       Decimal  @default(0) @db.Decimal(12, 2)
  
  // Delhivery Integration
  delhiveryApiKey   String?
  delhiveryClientId String?
  delhiveryEnabled  Boolean  @default(false)
  delhiveryLastSync DateTime?
  
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  users             User[]
  orders            Order[]
  pickups           Pickup[]
  warehouses        Warehouse[]
  invoices          Invoice[]
  walletTransactions WalletTransaction[]
  rateCaches        RateCache[]
  tickets           Ticket[]
  
  @@index([email])
}

enum ShippingType {
  B2C
  B2B
}

model Warehouse {
  id              String   @id @default(cuid())
  merchantId      String
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  
  name            String
  contactPerson   String?
  phone           String
  email           String?
  address         String
  city            String
  state           String
  pincode         String
  
  isActive        Boolean  @default(true)
  isDefault       Boolean  @default(false)
  
  // Delhivery sync status
  delhiverySynced Boolean  @default(false)
  delhiveryName   String?  // Exact name registered in Delhivery (case-sensitive)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  orders          Order[]
  pickups         Pickup[]
  
  @@index([merchantId])
  @@index([pincode])
}

model Order {
  id                String      @id @default(cuid())
  orderNumber       String      @unique
  merchantId        String
  merchant          Merchant    @relation(fields: [merchantId], references: [id])
  userId            String?
  user              User?       @relation(fields: [userId], references: [id])
  warehouseId       String?
  warehouse         Warehouse?  @relation(fields: [warehouseId], references: [id])
  
  // Customer
  customerName      String
  customerPhone     String
  customerEmail     String?
  
  // Shipping address
  shippingAddress   String
  shippingCity      String
  shippingState     String
  shippingPincode   String
  shippingLandmark  String?
  
  // Product
  productName       String
  productValue      Decimal     @db.Decimal(10, 2)
  quantity          Int         @default(1)
  
  // Payment
  paymentMode       PaymentMode
  codAmount         Decimal?    @db.Decimal(10, 2)
  
  // Shipping
  weight            Decimal     @db.Decimal(8, 2)
  length            Decimal?    @db.Decimal(8, 2)
  breadth           Decimal?    @db.Decimal(8, 2)
  height            Decimal?    @db.Decimal(8, 2)
  volumetricWeight  Decimal?    @db.Decimal(8, 2)
  chargeableWeight  Decimal?    @db.Decimal(8, 2)
  
  // Courier
  awbNumber         String?     @unique
  courierName       String?
  labelUrl          String?
  manifestUrl       String?
  
  // Status
  status            OrderStatus @default(PENDING)
  trackingStatus    String?
  
  // Delivery
  expectedDelivery  DateTime?
  actualDelivery    DateTime?
  
  // B2B specific
  isB2B             Boolean     @default(false)
  gstNumber         String?
  invoiceNumber     String?
  ewayBillNumber    String?
  deliveryType      String?
  slotDate          DateTime?
  slotTime          String?
  
  // Metadata
  channel           String?
  notes             String?
  tags              String[]
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  packages          Package[]
  trackingEvents    TrackingEvent[]
  tickets           Ticket[]
  
  @@index([merchantId])
  @@index([userId])
  @@index([warehouseId])
  @@index([status])
  @@index([awbNumber])
  @@index([orderNumber])
  @@index([customerPhone])
  @@index([createdAt])
}

enum PaymentMode {
  PREPAID
  COD
}

enum OrderStatus {
  PENDING
  PROCESSING
  READY_TO_SHIP
  MANIFESTED
  PICKED_UP
  IN_TRANSIT
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELLED
  RTO
  RTO_DELIVERED
  FAILED
}

model Package {
  id          String   @id @default(cuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  weight      Decimal  @db.Decimal(8, 2)
  length      Decimal  @db.Decimal(8, 2)
  breadth     Decimal  @db.Decimal(8, 2)
  height      Decimal  @db.Decimal(8, 2)
  reference   String?
  
  createdAt   DateTime @default(now())
  
  @@index([orderId])
}

model TrackingEvent {
  id          String   @id @default(cuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  status      String
  statusCode  String?
  location    String?
  remarks     String?
  timestamp   DateTime
  
  rawData     Json?
  
  createdAt   DateTime @default(now())
  
  @@index([orderId])
  @@index([timestamp])
}

model Pickup {
  id                String       @id @default(cuid())
  pickupNumber      String       @unique
  merchantId        String
  merchant          Merchant     @relation(fields: [merchantId], references: [id])
  userId            String?
  user              User?        @relation(fields: [userId], references: [id])
  warehouseId       String
  warehouse         Warehouse    @relation(fields: [warehouseId], references: [id])
  
  scheduledDate     DateTime
  scheduledTime     String?
  timeSlot          String?
  
  courierName       String
  manifestId        String?
  
  status            PickupStatus @default(SCHEDULED)
  
  orderCount        Int          @default(0)
  totalWeight       Decimal?     @db.Decimal(10, 2)
  
  notes             String?
  
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  @@index([merchantId])
  @@index([warehouseId])
  @@index([scheduledDate])
  @@index([status])
}

enum PickupStatus {
  SCHEDULED
  OUT_FOR_PICKUP
  PICKED_UP
  FAILED
  CANCELLED
}

model Invoice {
  id              String   @id @default(cuid())
  invoiceNumber   String   @unique
  merchantId      String
  merchant        Merchant @relation(fields: [merchantId], references: [id])
  
  amount          Decimal  @db.Decimal(12, 2)
  tax             Decimal  @default(0) @db.Decimal(10, 2)
  totalAmount     Decimal  @db.Decimal(12, 2)
  
  dueDate         DateTime?
  paidAt          DateTime?
  status          InvoiceStatus @default(PENDING)
  
  periodStart     DateTime
  periodEnd       DateTime
  
  fileUrl         String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([merchantId])
  @@index([status])
  @@index([invoiceNumber])
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

model WalletTransaction {
  id          String            @id @default(cuid())
  merchantId  String
  merchant    Merchant          @relation(fields: [merchantId], references: [id])
  
  amount      Decimal           @db.Decimal(12, 2)
  type        TransactionType
  status      TransactionStatus @default(PENDING)
  
  reference   String?
  description String?
  
  balanceBefore Decimal         @db.Decimal(12, 2)
  balanceAfter  Decimal         @db.Decimal(12, 2)
  
  createdAt   DateTime          @default(now())
  
  @@index([merchantId])
  @@index([createdAt])
  @@index([type])
}

enum TransactionType {
  RECHARGE
  DEBIT
  REFUND
  COD_REMITTANCE
  ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model ServiceabilityCache {
  id          String   @id @default(cuid())
  pincode     String   @unique
  city        String?
  state       String?
  serviceable Boolean
  couriers    String[]
  
  updatedAt   DateTime @updatedAt
  
  @@index([pincode])
}

model RateCache {
  id                String   @id @default(cuid())
  merchantId        String
  merchant          Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  
  originPincode     String
  destinationPincode String
  weight            Decimal  @db.Decimal(8, 2)
  paymentMode       String
  
  rate              Decimal  @db.Decimal(10, 2)
  courierName       String
  
  expiresAt         DateTime
  createdAt         DateTime @default(now())
  
  @@unique([merchantId, originPincode, destinationPincode, weight, paymentMode, courierName])
  @@index([expiresAt])
}

model Ticket {
  id              String        @id @default(cuid())
  ticketNumber    String        @unique
  merchantId      String
  merchant        Merchant      @relation(fields: [merchantId], references: [id])
  userId          String?
  user            User?          @relation(fields: [userId], references: [id])
  orderId         String?
  order           Order?         @relation(fields: [orderId], references: [id])
  
  type            TicketType
  subject         String
  description     String
  priority        TicketPriority @default(MEDIUM)
  status          TicketStatus   @default(OPEN)
  
  // Resolution
  resolvedBy      String?        // Admin user ID
  resolvedAt      DateTime?
  resolution      String?
  
  // SLA tracking
  slaHours        Int            @default(48) // Default 48 hours SLA
  dueAt           DateTime       // Calculated: createdAt + slaHours
  
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  @@index([merchantId])
  @@index([userId])
  @@index([orderId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
}

enum TicketType {
  DELIVERY_ISSUE
  WEIGHT_DISPUTE
  LOST_DAMAGED
  COURIER_ESCALATION
  BILLING_ISSUE
  PICKUP_ISSUE
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}
